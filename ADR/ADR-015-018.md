### ADR-015 : Pivot vers une Persistance Intelligente via API REST
**Statut : Réalisé**

**1. Référence ADR** : ADR-015 - Ingestion via Obsidian Local REST API.

**2. Analyse / Point de Discussion** : L'implémentation actuelle dans `storage_manager.py` (méthode `update_dashboard`) utilise des écritures de fichiers bruts. Cela rend Océane "aveugle" au contenu déjà existant dans Obsidian (anciennes sessions, notes manuelles).

**3. Explication Détaillée** : 
*   **Robustesse de la Justification** : L'API `coddingtonbear` permet d'utiliser le verbe `PATCH`. C'est crucial pour l'enrichissement sémantique sans risque de corruption de fichier par accès concurrent (si l'utilisateur écrit dans Obsidian en même temps).
*   **Alignement Stratégique** : Passer d'un mode "Push" (j'écris sans savoir) à un mode "Sync" (je vérifie, puis j'écris/ajoute).

**4. Suggestion / Proposition** :
*   **Modification de `Config`** : Ajouter `OBSIDIAN_API_KEY` et `OBSIDIAN_PORT`.
*   **Modification de `MemoryManager`** : Remplacer les écritures `with open()` par un client `httpx` ou `requests`.
*   **Texte spécifique** : "Toute interaction avec le Vault Obsidian doit être abstraite via une classe `ObsidianBridge`. Les fichiers locaux dans `logs/` servent de backup (fail-safe), mais l'API est la cible primaire."

**5. Impact** : Permet une interaction en temps réel entre l'IA et l'interface utilisateur d'Obsidian.

**Amendement pour ADR-015 (Section Justification)** :
L'implémentation du verbe PATCH n'a pas pu être réalisée, et la stratégie actuelle utilise Read-Modify-Write (GET + PUT) pour maximiser la compatibilité avec le plugin Local REST API. Le risque de conflit d'écriture (Race Condition) est jugé acceptable pour un usage mono-utilisateur local, comparé à la complexité de gestion des diffs partiels.

---

### ADR-016 : Segmentation des Notes en Unités Atomiques (Zettelkasten)
**Statut : Réalisé**

**1. Référence ADR** : ADR-016 - Stratégie d'Atomicité des Notes.

**2. Analyse / Point de Discussion** : Actuellement, `synthesizer.py` agrège tout dans un seul "Dashboard". Cela crée des documents trop longs qui diluent les concepts.

**3. Explication Détaillée** : 
*   **Respect du Zettelkasten** : Pour qu'un graphe de connaissances soit utile, les nœuds doivent être atomiques (un concept = une note).
*   **Modularité** : Facilite la réutilisation d'un concept précis (ex: "Double Immunité") dans de futurs briefings.

**4. Suggestion / Proposition** :
*   **Modification de `ANALYST_PROMPT`** : Modifier la mission pour forcer l'extraction de "Fiches Concepts".
*   **Structure de sortie attendue** :
    ```markdown
    --- CONCEPTS IDENTIFIÉS ---
    TITRE: Nom du concept
    CONTENU: Définition atomique
    TAGS: [Tag1, Tag2]
    --- FIN CONCEPTS ---
    ```
*   **Logique Python** : Le `analyst_process` dans `main.py` doit parser ce bloc et appeler `MemoryManager.create_atomic_note()` pour chaque concept identifié, en plus de mettre à jour le Dashboard global.

**5. Impact** : Population automatique du coffre Obsidian avec des fiches de connaissances prêtes à l'emploi.

---

### ADR-017 : Logique de Consolidation (Enrichissement vs Doublon)
**Statut : Réalisé**

**1. Référence ADR** : ADR-017 - Gestion de la Redondance Sémantique.

**2. Analyse / Point de Discussion** : C'est le point le plus critique de votre architecture. Sans dédoublonnage, Océane créera 50 notes sur le même sujet au fil des mois.

**3. Explication Détaillée** : 
*   **Pérennité** : Utiliser `vector_manager.py` non seulement pour le RAG, mais comme **gardien de l'intégrité**.
*   **Robustesse** : Une similarité de 0.90 (Sentence Transformer) est un seuil fiable pour décider d'une fusion (Merge) plutôt que d'une création.

**4. Suggestion / Proposition** :
*   Intégrer une méthode `find_existing_concept(text)` dans `VectorManager`.
*   **Algorithme d'archivage** :
    1.  Calculer l'embedding du nouveau concept.
    2.  Si similarité > 0.90 avec une note existante :
        *   Utiliser `API PATCH` pour ajouter le nouveau texte à la fin de la note existante.
    3.  Sinon :
        *   Utiliser `API PUT` pour créer une nouvelle note.
    4.  Cette étape se réalise à la fermeture (utilisation du script "stop") de la session pour ne pas impacter les performances en cours d'exécution (et rendre disponible le sentence transformer sans écraser la taxonomie en cours d'utilisation)

**5. Impact** : Création de notes "Evergreen" qui s'enrichissent organiquement avec le temps.

**Stratégie d'implémentation (Version Révisée) :**
Le processus de consolidation est exécuté en **continu (Asynchrone)** par le processus Analyste, et non à l'arrêt du système.
1.  **Garde-fou Physique (Fast Path)** : Vérification immédiate si un fichier `.md` porte exactement le même nom nettoyé. Si oui -> `Append` direct (Fusion).
2.  **Recherche Vectorielle (Slow Path)** : Si aucun fichier homonyme, calcul de l'embedding et recherche dans ChromaDB (Seuil dist < 0.20). Si trouvé -> `Append` (Fusion Sémantique).
3.  **Création (Fallback)** : Sinon -> Création d'une nouvelle note atomique.

---

### ADR-018 : Standardisation du Frontmatter YAML
**Statut : obsolète**

**1. Référence ADR** : ADR-018 - Standardisation du Metadata Schema.

**2. Analyse / Point de Discussion** : La méthode `create_atomic_note` actuelle dans `storage_manager.py` utilise un YAML minimaliste. 

**3. Explication Détaillée** : 
*   **Pérennité** : Pour utiliser des plugins comme *Dataview* ou *Graph Analysis*, le schéma doit être rigoureux.
*   **Clarté** : Permet de distinguer les notes générées par Océane des notes rédigées manuellement.

**4. Suggestion / Proposition** :
Forcer le schéma suivant dans chaque note générée :
```yaml
---
id: "{{timestamp}}"
type: concept
status: nascent  # ou evergreen
tags: {{tags_from_router}}
source: [[{{session_id}}]]
updated: {{datetime_now}}
---
```
*   **Action** : Injecter ces champs via le `MemoryManager` lors de l'appel API.

**5. Impact** : Organisation automatique par Obsidian (tri par tags, recherche par statut).

---


### ADR-018R (Révisé) : Standardisation du Metadata Schema

Voici la version finale qui aligne le template actuel (Obsidian - Linter) avec les besoins futurs du moteur (poids notamment).

**Statut :** Accepté

**1. Contexte**
Le système Océane génère des notes atomiques qui doivent s'insérer dans un coffre Obsidian existant géré par le plugin *Linter*. Le schéma de métadonnées (Frontmatter) doit être identique pour les notes humaines et les notes machine afin de permettre des requêtes Dataview unifiées et le calcul futur du "Poids".

**2. Décision**
Le `MemoryManager` générera systématiquement le bloc YAML suivant pour toute nouvelle note :

```yaml
---
uid: {{TIMESTAMP_ID}}
aliases: []
tags:
  - type/concept
  - état/graine
poids: 50
source:
  - IA
  - [[{{SESSION_ID}}]]
date_created: {{CURRENT_DATE}}
date_updated: {{CURRENT_DATE}}
---
```

**3. Justification des Champs**
*   **`uid`** : Clé primaire (Format : `YYYYMMDDHHMMSS`) pour l'unicité.
*   **`poids: 50`** : Valeur médiane par défaut. Permettra aux algorithmes (ADR-022) de baisser ou monter l'importance sans partir de zéro.
*   **`état/graine`** : Indique clairement que c'est une note brute générée par l'IA, nécessitant une relecture (Jardinage) pour passer en `état/sapling`.
*   **`source`** : Double entrée pour filtrer par "IA" ou retrouver le contexte via le lien vers le Dashboard de session.

**4. Conséquences**
*   Nécessite une mise à jour immédiate de la méthode `create_atomic_note` dans `storage_manager.py`.
*   Garantit que le plugin Linter ne "cassera" pas le formatage lors de son prochain passage.


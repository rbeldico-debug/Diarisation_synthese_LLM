### ADR-015 : Pivot vers une Persistance Intelligente via API REST
**Statut : Proposé**

**1. Référence ADR** : ADR-015 - Ingestion via Obsidian Local REST API.

**2. Analyse / Point de Discussion** : L'implémentation actuelle dans `storage_manager.py` (méthode `update_dashboard`) utilise des écritures de fichiers bruts. Cela rend Océane "aveugle" au contenu déjà existant dans Obsidian (anciennes sessions, notes manuelles).

**3. Explication Détaillée** : 
*   **Robustesse de la Justification** : L'API `coddingtonbear` permet d'utiliser le verbe `PATCH`. C'est crucial pour l'enrichissement sémantique sans risque de corruption de fichier par accès concurrent (si l'utilisateur écrit dans Obsidian en même temps).
*   **Alignement Stratégique** : Passer d'un mode "Push" (j'écris sans savoir) à un mode "Sync" (je vérifie, puis j'écris/ajoute).

**4. Suggestion / Proposition** :
*   **Modification de `Config`** : Ajouter `OBSIDIAN_API_KEY` et `OBSIDIAN_PORT`.
*   **Modification de `MemoryManager`** : Remplacer les écritures `with open()` par un client `httpx` ou `requests`.
*   **Texte spécifique** : "Toute interaction avec le Vault Obsidian doit être abstraite via une classe `ObsidianBridge`. Les fichiers locaux dans `logs/` servent de backup (fail-safe), mais l'API est la cible primaire."

**5. Impact** : Permet une interaction en temps réel entre l'IA et l'interface utilisateur d'Obsidian.

---

### ADR-016 : Segmentation des Notes en Unités Atomiques (Zettelkasten)
**Statut : Proposé**

**1. Référence ADR** : ADR-016 - Stratégie d'Atomicité des Notes.

**2. Analyse / Point de Discussion** : Actuellement, `synthesizer.py` agrège tout dans un seul "Dashboard". Cela crée des documents trop longs qui diluent les concepts.

**3. Explication Détaillée** : 
*   **Respect du Zettelkasten** : Pour qu'un graphe de connaissances soit utile, les nœuds doivent être atomiques (un concept = une note).
*   **Modularité** : Facilite la réutilisation d'un concept précis (ex: "Double Immunité") dans de futurs briefings.

**4. Suggestion / Proposition** :
*   **Modification de `ANALYST_PROMPT`** : Modifier la mission pour forcer l'extraction de "Fiches Concepts".
*   **Structure de sortie attendue** :
    ```markdown
    --- CONCEPTS IDENTIFIÉS ---
    TITRE: Nom du concept
    CONTENU: Définition atomique
    TAGS: [Tag1, Tag2]
    --- FIN CONCEPTS ---
    ```
*   **Logique Python** : Le `analyst_process` dans `main.py` doit parser ce bloc et appeler `MemoryManager.create_atomic_note()` pour chaque concept identifié, en plus de mettre à jour le Dashboard global.

**5. Impact** : Population automatique du coffre Obsidian avec des fiches de connaissances prêtes à l'emploi.

---

### ADR-017 : Logique de Consolidation (Enrichissement vs Doublon)
**Statut : Proposé**

**1. Référence ADR** : ADR-017 - Gestion de la Redondance Sémantique.

**2. Analyse / Point de Discussion** : C'est le point le plus critique de votre architecture. Sans dédoublonnage, Océane créera 50 notes sur le même sujet au fil des mois.

**3. Explication Détaillée** : 
*   **Pérennité** : Utiliser `vector_manager.py` non seulement pour le RAG, mais comme **gardien de l'intégrité**.
*   **Robustesse** : Une similarité de 0.90 (Sentence Transformer) est un seuil fiable pour décider d'une fusion (Merge) plutôt que d'une création.

**4. Suggestion / Proposition** :
*   Intégrer une méthode `find_existing_concept(text)` dans `VectorManager`.
*   **Algorithme d'archivage** :
    1.  Calculer l'embedding du nouveau concept.
    2.  Si similarité > 0.90 avec une note existante :
        *   Utiliser `API PATCH` pour ajouter le nouveau texte à la fin de la note existante.
    3.  Sinon :
        *   Utiliser `API PUT` pour créer une nouvelle note.
    4.  Cette étape se réalise à la fermeture (utilisation du script "stop") de la session pour ne pas impacter les performances en cours d'exécution (et rendre disponible le sentence transformer sans écraser la taxonomie en cours d'utilisation)

**5. Impact** : Création de notes "Evergreen" qui s'enrichissent organiquement avec le temps.

---

### ADR-018 : Standardisation du Frontmatter YAML
**Statut : Proposé**

**1. Référence ADR** : ADR-018 - Standardisation du Metadata Schema.

**2. Analyse / Point de Discussion** : La méthode `create_atomic_note` actuelle dans `storage_manager.py` utilise un YAML minimaliste. 

**3. Explication Détaillée** : 
*   **Pérennité** : Pour utiliser des plugins comme *Dataview* ou *Graph Analysis*, le schéma doit être rigoureux.
*   **Clarté** : Permet de distinguer les notes générées par Océane des notes rédigées manuellement.

**4. Suggestion / Proposition** :
Forcer le schéma suivant dans chaque note générée :
```yaml
---
id: "{{timestamp}}"
type: concept
status: nascent  # ou evergreen
tags: {{tags_from_router}}
source: [[{{session_id}}]]
updated: {{datetime_now}}
---
```
*   **Action** : Injecter ces champs via le `MemoryManager` lors de l'appel API.

**5. Impact** : Organisation automatique par Obsidian (tri par tags, recherche par statut).

---

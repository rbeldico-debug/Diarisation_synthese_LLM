### ADR-019 : Gestion de l'État Hybride (Persistance Différée)

**Date :** 2025-12-29

**Statut :** Accepté

**Contexte :**
Objectif est de mettre en place un assistant Zettelkasten Dynamique utilise des variables "vivantes" (Poids dynamique, Calcul de l'Attention, Recrutement Bottom-Up, Ignition, Amplification Top-Down) qui fluctuent rapidement au cours d'une session de travail via les algorithmes.
Cependant, Obsidian (l'interface utilisateur) repose sur des fichiers Markdown. Écrire ces fluctuations en temps réel dans les fichiers `.md` provoquerait :
1.  Des conflits d'accès fichiers (File Locking).
2.  Un "clignotement" de l'interface Obsidian (rechargement).
3.  Une saturation inutile des I/O disques.
4.  Une pollution de l'historique de versions (git/snapshots).

**Décision :**
Nous adoptons une **Architecture de Gestion d'État Hybride** :
1.  **Au Chargement (Start)** : Le programme lit l'état persistant (Frontmatter des `.md`) et construit une représentation du Graphe en Mémoire RAM (Objet `GraphState`).
2.  **En Session (Runtime)** : Toutes les modifications algorithmiques concernant l'état du système (calcul d'Ignition, modification du Poids dynamique suite à l'Attention, dépréciation temporelle) se font **uniquement en RAM** sur l'objet `GraphState`.
3.  **À Intervalle régulier (toutes les unités de temps) :** Des modifications de `Tags`, nouveaux `Nœuds`, nouveaux `Liens`, nouveau contenu sont implémentés dans le réseau et dans le `dashboard.md`. 
4.  **À la Clôture (End)** : Une procédure de sauvegarde est déclenchée (fin de session ou commande explicite) pour écrire les valeurs finales pertinentes (dernier `Poids`, `Date`, `Tags`) dans les fichiers `.md`.

**Précisions :**
- La philosophie derrière les différents états du système est résumée dans [[Mécanisme d'Attention (Sélection)]]
- L'algorithme concernant les modifications de `tags` fait appel à des mécanismes déterministes (Cf. [[00_Tags]])
- Le calcul des `Poids` est décrit dans le document [[Poids]]. 

**Conséquences :**
*   **Positives :** Performance maximale (calculs en mémoire), aucun conflit d'écriture avec Obsidian pendant l'édition utilisateur, fluidité de l'expérience.
*   **Négatives :** Risque de perte de "l'état mental" du système en cas de crash brutal du programme avant la sauvegarde (considéré acceptable car le Poids est recalculable et n'est pas une donnée critique utilisateur).
*   **Technique :** Nécessite d'implémenter un `Graceful Shutdown` pour assurer l'écriture en fin de session.

---

### ADR-020 : Stratégie d'Écriture de Contenu "Append-Only" et Traçabilité

**Date :** 2025-12-29

**Statut :** Accepté

**Contexte :**
Le système génère du contenu (synthèses, atomisations, suggestions) via les LLMs. Il doit insérer ce contenu dans les notes existantes sans risquer d'écraser le travail de l'utilisateur ou de créer des conflits de fusion si l'utilisateur édite la même note.
La distinction entre la source "Humaine" = `Moi` et "Machine" = `IA` doit être explicite (section `source` du YAML).

**Décision :**
1.  **Stratégie "Append-Only"** : Pour tout ajout de contenu textuel (body), le système écrit systématiquement **à la fin du fichier** `.md`, après un saut de ligne ou un séparateur défini (ex: `---`). Il ne modifie ni ne supprime jamais le texte existant dans le corps de la note.
2.  **Traçabilité des Métadonnées** :
    *   Toute modification par le système ajoute ou vérifie la présence `IA` dans la section liste `source`.
    *   Les `Tags` sont gérés par logique additive ou conditionnelle (Règles de priorité définies section `00_Tags`).
3.  **Visualisation** : L'utilisateur distingue visuellement les apports de l'IA par leur positionnement (bas de page) et peut les refactoriser manuellement s'il le souhaite.

**Conséquences :**
*   **Positives :** Sécurité absolue des données utilisateur (zéro écrasement), historique clair, intégration simple.
*   **Négatives :** Les notes peuvent devenir longues si l'IA génère beaucoup ; nécessite une action de jardinage manuel (refactoring) pour intégrer les idées de l'IA dans le corps principal si pertinent.

---

### ADR-021 : Architecture de Boucle Cognitive Asynchrone (Fast & Slow Lanes)

**Date :** 2025-12-29

**Statut :** Accepté.

**Contexte :**
Le système doit gérer des tâches à échelles de temps très différentes :
1.  Traitement immédiat des inputs vocaux/texte (Réactivité).
2.  Organisation profonde, atomisation et raisonnement (Charge lourde).
3.  Synthèse interactive régulière (Rythme).
Utiliser un seul processus séquentiel bloquerait le système pendant les raisonnements longs.

**Décision :**
Le moteur d'exécution est divisé en **Boucles Asynchrones Parallèles** :
1.  **La Voie Rapide (Fast Lane - MistralNemo + RAG)** :
    *   *Trigger* : À chaque Input (Vocal/Texte).
    *   *Action* : Transcription, Catégorisation immédiate, Tagging rapide, Mise en file d'attente pour le traitement profond.
2.  **La Voie Profonde (Deep Lane - GPT-OSS:20b)** : (Modèle CoT, ANALYST_PROMPT) 
    *   *Trigger* : En continu (Boucle infinie qui prend en considération les entrées utilisateur, activation des [[Mécanisme d'Attention (Sélection)]] et recalcul du `Poids` ([[Poids]]), prise en compte du différentiel par rapport au poids précédent Cf ADR-022).
    *   *Préparation* : Prompt du modèle alimenté par les contenus remontés via les Mécanismes d'Attention (Sélection).
    *   *Action* : Dépile les inputs, exécute les Chaînes de Pensées (CoT), Atomise les notes, Calcule les similarités sémantiques pour les titres des nouvelles notes, Met à jour le "Tableau de Bord".
3.  **La Voie de Synthèse (Interaction Lane)** : (Deep Lane - GPT-OSS:20b) : (Modèle CoT, SYSTEM_PROMPT)
    *   *Trigger* : Timer (toutes les ~2 min) ou `Seuil d'Ignition` atteint. 
    *   *Préparation* : Prompt du modèle alimenté par les contenus remontés via les Mécanismes d'Attention (Sélection).
    *   *Action* : Analyse l'état actuel (Tableau de Bord), génère une synthèse/stimulus audio ou texte pour l'utilisateur.

**Conséquences :**
*   **Positives :** Le système reste réactif aux inputs même pendant qu'il réfléchit ("Ne bloque pas"). Maximisation de l'utilisation des ressources locales (GPU/CPU).
*   **Négatives :** Complexité de gestion de la file d'attente (Queue) et de la synchronisation des données partagées entre les processus (Thread-safety).

---

### ADR-022 : Algorithme Composite du Poids et Mécanisme d'Attention

**Date :** 2025-12-30
**Statut :** Accepté.

**Contexte**
Pour simuler une "conscience" et pertinence contextuelle, le système ne peut pas traiter toutes les notes sur un pied d'égalité. Il doit quantifier l'attention à apporter à chaque note à chaque cycle d'exécution ($t$). Ce mécanisme d'attention détermine quels Nœuds sont envoyés dans le contexte du LLM (Retrieval).
Le système distingue le **Poids Structurel** (persistant) de la **Tension d'Activation** (volatile en RAM).

**Décision**
Le **Poids d'Activation ($W$)** d'un Nœud à l'instant $t$ est calculé dynamiquement selon la formule composite :

$$W_t = \text{Base}(S, C, T) + \text{Dynamique}(\text{Stimulus}, \text{TopDown}) - \text{Frein}(\text{Fatigue})$$

#### 1. Composantes de Base (Le "Potentiel de Repos")
Ces valeurs changent peu au cours d'une session.
*   **$S$ (Structure)** : Centralité du nœud.
    *   Calcul : $S = (\alpha \cdot \log(1 + \text{In})) + (\delta \cdot \log(1 + \text{Out}))$
*   **$C$ (Chaleur/Fraîcheur)** : Récence de la modification.
    *   Calcul : $C = \frac{1}{(Age_{jours} \cdot \text{coef}) + 1} + \text{base}$
*   **$T$ (Tension/Confiance)** : Statut de maturité de la note.
    *   Calcul : $T = \gamma \cdot \text{FacteurEtat}$ (ex: Graine=0.2, Sapling=0.5, Evergreen=1.0).

#### 2. Mécanismes d'État du Système (La Dynamique)
Les coefficients $\alpha, \beta, \gamma, \delta$ sont modulés par un "Méta-Contrôleur" (style épistémologique) selon le mode (/ ex Exploration, Consolidation, Approfondissement, Synthèse, ...).

*   **A. Recrutement Bottom-Up (Stimulus)**
    *   *Déclencheur :* Input utilisateur.
    *   *Action :* Recherche vectorielle des $k$ nœuds les plus proches.
    *   *Effet :* Ajout d'un **Bonus d'Activation** immédiat proportionnel à la similarité sémantique.

*   **B. Ignition (Seuil de Conscience)**
    *   *Déclencheur :* Fin de calcul des poids.
    *   *Règle :* Sélection "Winner-takes-all".
    *   *Condition :* Si $W_t > \text{Seuil}_{Ignition}$, le nœud devient **CONSCIENT** (envoyé au LLM et affiché) ET activé.
    *   *Effet :* Incrémente le compteur `consecutive_activations` du nœud.

*   **C. Amplification Top-Down (Propagation)**
    *   *Déclencheur :* Cycle suivant une activation.
    *   *Action :* Les nœuds actifs distribuent une fraction de leur énergie à leurs voisins sortants (Links).
    *   *Effet :* Assure la cohérence du fil de pensée (si "Pomme" est actif, "Arbre" reçoit de l'énergie).

#### 3. Régulation Homéostatique (Fatigue Synaptique)
Pour éviter le "Larsen Cognitif" (boucle obsessionnelle sur le même nœud), une pénalité non-linéaire est appliquée.

*   **Fonction de Fatigue ($F$)** :
    *   Soit $n$ le nombre d'activations consécutives (cycles d'Ignition).
    *   Soit $N_{max}$ le seuil de tolérance (ex: 4 cycles).
    *   $$Penalty = \left( \frac{n}{N_{max}} \right)^3$$
*   **Comportement :**
    *   $n=1, 2$ : Pénalité négligeable (Maintien du focus autorisé).
    *   $n=3, 4$ : Pénalité croissante (Le sujet commence à s'épuiser).
    *   $n > N_{max}$ : Pénalité massive (Période réfractaire forcée, le nœud s'éteint pour laisser place aux autres). $N_{max}$ peut être pondéré par le style épistémologique. 

**Conséquences**
*   **Positives :** Le système possède une "mémoire de travail" (Hystérésis) mais est forcé de changer de sujet après un certain temps (Fatigue). 
*   **Négatives :** Complexité de mise au point (Tuning). Si la fatigue est trop faible, le système boucle. Si elle est trop forte, le système semble "TDAH" (saute du coq à l'âne).

---

### Analyse de Cohérence Globale

Ces 4 ADRs forment une base technique solide pour votre objectif.
*   **ADR-0019 & 0020** protègent vos données (Priorité Sécurité).
*   **ADR-0021** assure la performance et l'expérience utilisateur (Priorité Fluidité).
*   **ADR-0022** définit le "Cerveau" du système (Priorité Intelligence).

**Prochaine étape suggérée :** Valider ces ADRs, puis commencer l'implémentation de la "Boucle Rapide" (ADR-0021) et de la structure de données en mémoire (ADR-0019).